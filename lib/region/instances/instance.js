// Generated by CoffeeScript 1.4.0
(function() {
  var BaseModel, Tags, comerr, createInstance, gumbo, outcome, stepc, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  gumbo = require("gumbo");

  _ = require("underscore");

  comerr = require("comerr");

  outcome = require("outcome");

  stepc = require("stepc");

  createInstance = require("../../utils/createInstance");

  BaseModel = require("../base/model");

  Tags = require("../tags");

  /*
  
  Server States:
  
  +--------+---------------+
  |  Code  |     State     |
  +--------+---------------+
  |   0    |    pending    | 
  |  16    |    running    |
  |  32    | shutting-down | 
  |  48    |  terminated   |
  |  64    |   stopping    | 
  |  80    |   stopped     |
  +--------+---------------+
  */


  module.exports = (function(_super) {

    __extends(_Class, _super);

    /*
    */


    function _Class(collection, region, item) {
      _Class.__super__.constructor.call(this, collection, region, item);
      this.tags = new Tags(this);
    }

    /*
        Function: start
          Starts the server. Note: if the server is stopping, ectwo will wait
          until the server has stopped completely before running the "start" command
    
        Parameters:
          callback - Called once the srver has properly started
    */


    _Class.prototype.start = function(callback) {
      return this._runCommand("running", _.bind(this.start2, this, callback), callback);
    };

    /*
        secondary start function that bypasses the "running" check
    */


    _Class.prototype.start2 = function(callback) {
      var state,
        _this = this;
      state = this.get("state");
      if (/stopped/.test(state)) {
        this._callAndWaitUntilState("StartInstances", "running", callback);
      } else {

      }
      if (/shutting-down|stopping/.test(state)) {
        this._waitUntilState("stopped|terminated", function() {
          return _this.start(callback);
        });
      } else {

      }
      if (/pending/.test(state)) {
        return this._waitUntilState("running", callback);
      }
    };

    /*
        Function: stop
          Stops the server. 
    
        Parameters:
          callback - Called once the server has stopped
    */


    _Class.prototype.stop = function(callback) {
      return this._runCommand("stopped", _.bind(this._stop2, this, callback), callback);
    };

    /*
    */


    _Class.prototype.reboot = function(callback) {
      var _this = this;
      return this.stop(outcome.e(callback).s(function() {
        return _this.start(callback);
      }));
    };

    /*
    */


    _Class.prototype.getAddress = function(callback) {
      return this.region.addresses.findOne({
        instanceId: this.get("_id")
      }).exec(callback);
    };

    /*
    */


    _Class.prototype._stop2 = function(callback) {
      var state,
        _this = this;
      state = this.get("state");
      if (/running/.test(state)) {
        this._callAndWaitUntilState("StopInstances", "stopped", callback);
      } else {

      }
      if (/stopping|shutting-down/.test(state)) {
        this._waitUntilState("stopped|terminated", function() {
          return _this.stop(callback);
        });
      } else {

      }
      if (/pending/.test(state)) {
        return this._waitUntilState("running", function() {
          return _this.stop(callback);
        });
      }
    };

    /*
        Function: restart
    
        Parameters:
    */


    _Class.prototype.restart = function(callback) {
      var _this = this;
      return this.stop(outcome.e(callback).s(function() {
        return _this.start(callback);
      }));
    };

    /*
        Function: terminate
    
        Terminates the EC2 instance
    
        Parameters:
    */


    _Class.prototype._destroy = function(callback) {
      return this._runCommand("terminated", _.bind(this.terminate2, this, callback), callback);
    };

    /*
    */


    _Class.prototype.terminate2 = function(callback) {
      return this._callAndWaitUntilState("TerminateInstances", "terminated", callback);
    };

    /*
        Function: getAMI
    
        Fetches the AMI of this instance
    
        Parameters:
    */


    _Class.prototype.getImage = function(callback) {};

    /*
        Function: createAMI
    
        Parameters:
          callback - called once the AMI is created
    
        Returns:
          The AMI
    */


    _Class.prototype.createImage = function(options, callback) {
      var o, self;
      o = outcome.e(callback);
      self = this;
      return stepc.async(function() {
        return self._ec2.call("CreateImage", {
          "InstanceId": this.get("_id"),
          name: new Date().toString()
        }, this);
      }, o.s(function(image) {}));
    };

    /*
        Function: clone
    
          Clones the server based on the AMI id, *and* the instance flavor (c1.medium perhaps)
    
        Parameters:
    
        Returns:
          The new EC2 instance
    */


    _Class.prototype.clone = function(callback) {
      var o, self;
      o = outcome.e(callback);
      self = this;
      return createInstance(this.region, {
        imageId: this.get("imageId"),
        flavor: this.get("type")
      }, result);
    };

    /*
       flow control helper that skips a method if the server
       is already running in the target state
    */


    _Class.prototype._skipIfState = function(state, end, next) {
      var self, stateTest,
        _this = this;
      stateTest = new RegExp(state);
      self = this;
      return self.reload(outcome.e(end).s(function(result) {
        if (stateTest.test(_this.get("state"))) {
          return end();
        } else {
          return next();
        }
      }));
    };

    /*
        Function: 
    
        Parameters:
    */


    _Class.prototype._runCommand = function(expectedState, runCommand, callback) {
      var _this = this;
      return this._skipIfState(expectedState, callback, function() {
        var state;
        state = _this.get("state");
        if (/terminated/.test(state)) {
          callback(new comerr.NotFound("The instance has been terminated."));
        } else {

        }
        if (!/stopping|stopped|shutting-down|running|pending/.test(state)) {
          return callback(new comerr.UnknownError("An unrecognized instance state was returned."));
        } else {
          return runCommand();
        }
      });
    };

    /*
    */


    _Class.prototype._callAndWaitUntilState = function(command, state, callback) {
      var fn,
        _this = this;
      fn = null;
      if (typeof command !== "function") {
        fn = function(callback) {
          return _this._ec2.call(command, {
            "InstanceId.1": _this.get("_id")
          }, callback);
        };
      } else {
        fn = command;
      }
      return fn(outcome.e(callback).s(function() {
        return _this._waitUntilState(state, callback);
      }));
    };

    /*
        Waits until the server reaches this particular state
        Parameters:
    */


    _Class.prototype._waitUntilState = function(state, callback) {
      var checkState,
        _this = this;
      checkState = function() {
        return _this._skipIfState(state, callback, function() {
          return setTimeout(checkState, 1000 * 3);
        });
      };
      return checkState();
    };

    return _Class;

  })(BaseModel);

}).call(this);
