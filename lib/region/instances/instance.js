// Generated by CoffeeScript 1.4.0
(function() {
  var BaseModel, Tags, comerr, copyTags, createInstance, findOneOrErr, gumbo, objectToTags, outcome, stepc, tagsToObject, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  gumbo = require("gumbo");

  _ = require("underscore");

  comerr = require("comerr");

  outcome = require("outcome");

  stepc = require("stepc");

  createInstance = require("../../utils/createInstance");

  BaseModel = require("../base/model");

  Tags = require("../tags");

  objectToTags = require("../../utils/objectToTags");

  tagsToObject = require("../../utils/tagsToObject");

  copyTags = require("../../utils/copyTags");

  findOneOrErr = require("../../utils/findOneOrErr");

  /*
  
  Server States:
  
  +--------+---------------+
  |  Code  |     State     |
  +--------+---------------+
  |   0    |    pending    | 
  |  16    |    running    |
  |  32    | shutting-down | 
  |  48    |  terminated   |
  |  64    |   stopping    | 
  |  80    |   stopped     |
  +--------+---------------
  */


  module.exports = (function(_super) {

    __extends(_Class, _super);

    /*
    */


    function _Class(collection, region, item) {
      _Class.__super__.constructor.call(this, collection, region, item);
      this.tags = new Tags(this);
    }

    /*
        Function: start
          Starts the server. Note: if the server is stopping, ectwo will wait
          until the server has stopped completely before running the "start" command
    
        Parameters:
          callback - Called once the srver has properly started
    */


    _Class.prototype.start = function(callback) {
      if (callback == null) {
        callback = (function() {});
      }
      return this._runCommand("running", _.bind(this.start2, this, callback), callback);
    };

    /*
        secondary start function that bypasses the "running" check
    */


    _Class.prototype.start2 = function(callback) {
      var state,
        _this = this;
      state = this.get("state");
      if (/stopped/.test(state)) {
        this._callAndWaitUntilState("StartInstances", "running", callback);
      } else {

      }
      if (/shutting-down|stopping/.test(state)) {
        this._waitUntilState("stopped|terminated", function() {
          return _this.start(callback);
        });
      } else {

      }
      if (/pending/.test(state)) {
        return this._waitUntilState("running", callback);
      }
    };

    /*
        Function: stop
          Stops the server. 
    
        Parameters:
          callback - Called once the server has stopped
    */


    _Class.prototype.stop = function(callback) {
      if (callback == null) {
        callback = (function() {});
      }
      return this._runCommand("stopped", _.bind(this._stop2, this, callback), callback);
    };

    /*
    */


    _Class.prototype.reboot = function(callback) {
      var _this = this;
      if (callback == null) {
        callback = (function() {});
      }
      return this.stop(outcome.e(callback).s(function() {
        return _this.start(callback);
      }));
    };

    /*
    */


    _Class.prototype.getAddress = function(callback) {
      return findOneOrErr(this.region.addresses, {
        instanceId: this.get("_id")
      }, callback);
    };

    /*
    */


    _Class.prototype._stop2 = function(callback) {
      var state,
        _this = this;
      state = this.get("state");
      if (/running/.test(state)) {
        this._callAndWaitUntilState("StopInstances", "stopped", callback);
      } else {

      }
      if (/stopping|shutting-down/.test(state)) {
        this._waitUntilState("stopped|terminated", function() {
          return _this.stop(callback);
        });
      } else {

      }
      if (/pending/.test(state)) {
        return this._waitUntilState("running", function() {
          return _this.stop(callback);
        });
      }
    };

    /*
        Function: terminate
    
        Terminates the EC2 instance
    
        Parameters:
    */


    _Class.prototype._destroy = function(callback) {
      return this._runCommand("terminated", _.bind(this.terminate2, this, callback), callback);
    };

    /*
    */


    _Class.prototype.terminate2 = function(callback) {
      return this._callAndWaitUntilState("TerminateInstances", "terminated", callback);
    };

    /*
        Function: getAMI
    
        Fetches the AMI of this instance
    
        Parameters:
    */


    _Class.prototype.getImage = function(callback) {
      return this.region.images.syncAndFindOne({
        instanceId: this.get("_id")
      }, callback);
    };

    /*
        Function: createAMI
    
        Parameters:
          callback - called once the AMI is created
    
        Returns:
          The AMI
    */


    _Class.prototype.createImage = function(options, callback) {
      var o, self,
        _this = this;
      o = outcome.e(callback);
      self = this;
      return this.stop(function() {
        options = {
          "InstanceId": _this.get("_id"),
          "Name": options.name || String(Date.now())
        };
        return _this._ec2.call("CreateImage", options, o.s(function(result) {
          return _this.region.images.syncAndFindOne({
            _id: result.imageId
          }, o.s(function(image) {
            return copyTags(_this, image, {
              createdAt: Date.now()
            }, o.s(function() {
              return callback(null, image);
            }));
          }));
        }));
      });
    };

    /*
        Function: clone
    
          Clones the server based on the AMI id, *and* the instance flavor (c1.medium perhaps)
    
        Parameters:
    
        Returns:
          The new EC2 instance
    */


    _Class.prototype.clone = function(callback) {
      var o, self;
      o = outcome.e(callback);
      self = this;
      return createInstance(this.region, {
        imageId: this.get("imageId"),
        flavor: this.get("type")
      }, result);
    };

    /*
        Function: 
    
        Parameters:
    */


    _Class.prototype._runCommand = function(expectedState, runCommand, callback) {
      var _this = this;
      return this._skipIfState(expectedState, callback, function() {
        var state;
        state = _this.get("state");
        if (/terminated/.test(state)) {
          callback(new comerr.NotFound("The instance has been terminated."));
        } else {

        }
        if (!/stopping|stopped|shutting-down|running|pending/.test(state)) {
          return callback(new comerr.UnknownError("An unrecognized instance state was returned."));
        } else {
          return runCommand();
        }
      });
    };

    /*
    */


    _Class.prototype._callAndWaitUntilState = function(command, state, callback) {
      var fn,
        _this = this;
      fn = null;
      if (typeof command !== "function") {
        fn = function(callback) {
          return _this._ec2.call(command, {
            "InstanceId.1": _this.get("_id")
          }, callback);
        };
      } else {
        fn = command;
      }
      return fn(outcome.e(callback).s(function() {
        return _this._waitUntilState(state, callback);
      }));
    };

    /*
        Waits until the server reaches this particular state
        Parameters:
    */


    _Class.prototype._waitUntilState = function(state, callback) {
      return this.waitUntilSync({
        state: state
      }, callback);
    };

    /*
    */


    _Class.prototype._skipIfState = function(state, end, callback) {
      return this._skipIfSynced({
        state: state
      }, end, callback);
    };

    return _Class;

  })(BaseModel);

}).call(this);
