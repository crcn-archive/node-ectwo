// Generated by CoffeeScript 1.4.0
(function() {
  var comerr, gumbo, outcome, stepc, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  gumbo = require("gumbo");

  _ = require("underscore");

  comerr = require("comerr");

  outcome = require("outcome");

  stepc = require("stepc");

  /*
  
  Server States:
  
  +--------+---------------+
  |  Code  |     State     |
  +--------+---------------+
  |   0    |    pending    | 
  |  16    |    running    |
  |  32    | shutting-down | 
  |  48    |  terminated   |
  |  64    |   stopping    | 
  |  80    |   stopped     |
  +--------+---------------+
  */


  module.exports = (function(_super) {

    __extends(_Class, _super);

    /*
    */


    function _Class(collection, _ec2, item) {
      this._ec2 = _ec2;
      this._sync = __bind(this._sync, this);

      _Class.__super__.constructor.call(this, collection, item);
    }

    /*
        Function: start
          Starts the server. Note: if the server is stopping, ectwo will wait
          until the server has stopped completely before running the "start" command
    
        Parameters:
          callback - Called once the srver has properly started
    */


    _Class.prototype.start = function(callback) {
      return this._runCommand("running", _.bind(this.start2, this, callback), callback);
    };

    /*
        secondary start function that bypasses the "running" check
    */


    _Class.prototype.start2 = function(callback) {
      var state,
        _this = this;
      state = this.get("state");
      if (/stopped/.test(state)) {
        this._ec2.call("StartInstances", {
          "InstanceId.1": this.get("instanceId")
        }, callback);
      } else {

      }
      if (/shutting-down|stopping/.test(state)) {
        this._waitUntilState("stopped|terminated", function() {
          return _this.start(callback);
        });
      } else {

      }
      if (/pending/.test(state)) {
        return this._waitUntilState("running", callback);
      }
    };

    /*
        Function: stop
          Stops the server. 
    
        Parameters:
          callback - Called once the server has stopped
    */


    _Class.prototype.stop = function(callback) {
      return this._runCommand("stopped", _.bind(this.stop2, this, callback), callback);
    };

    /*
    */


    _Class.prototype.stop2 = function(callback) {
      var state,
        _this = this;
      state = this.get("state");
      if (/running/.test(state)) {
        this._ec2.call("StopInstances", {
          "InstanceId.1": this.get("instanceId")
        }, callback);
      } else {

      }
      if (/stopping|shutting-down/.test(state)) {
        this._waitUntilState("stopped|terminated", function() {
          return _this.stop(callback);
        });
      } else {

      }
      if (/pending/.test(state)) {
        return this._waitUntilState("running", function() {
          return _this.stop(callback);
        });
      }
    };

    /*
        Function: restart
    
        Parameters:
    */


    _Class.prototype.restart = function(callback) {
      var _this = this;
      return this.stop(outcome.e(callback).s(function() {
        return _this.start(callback);
      }));
    };

    /*
        Function: terminate
    
        Terminates the EC2 instance
    
        Parameters:
    */


    _Class.prototype.terminate = function(callback) {
      return this._runCommand("terminated", _.bind(this.terminate2, this, callback), callback);
    };

    /*
    */


    _Class.prototype.terminate2 = function(callback) {
      return this._ec2.call("TerminateInstances", {
        "InstanceId.1": this.get("instanceId")
      }, callback);
    };

    /*
        Function: getAMI
    
        Fetches the AMI of this instance
    
        Parameters:
    */


    _Class.prototype.getAMI = function(callback) {};

    /*
        Function: createAMI
    
        Parameters:
          callback - called once the AMI is created
    
        Returns:
          The AMI
    */


    _Class.prototype.createAMI = function(callback) {
      var o,
        _this = this;
      o = outcome.e(callback);
      return stepc(function() {
        return _this.stop(_this);
      }, o.s(function() {}));
    };

    /*
        Function: clone
    
          Clones the server based on the AMI id, *and* the instance flavor (c1.medium perhaps)
    
        Parameters:
    
        Returns:
          The new EC2 instance
    */


    _Class.prototype.clone = function(callback) {};

    /*
        Function: refresh
    
        Refreshes the server from information about the EC2 Instance. Note - this function
        is called everytime you want to invoke a command against the server to make sure ECTwo can
        handle the server properly depending on its current state. starting an instance for instance 
        requires that an instance is in the "stopped" state.
    
        Parameters:
          callback
    */


    _Class.prototype.refresh = function(callback) {};

    /*
       flow control helper that skips a method if the server
       is already running in the target state
    */


    _Class.prototype._skipIfState = function(state, end, next) {
      var stateTest,
        _this = this;
      stateTest = new RegExp(state);
      return stepc(function() {
        return _this._sync(_this);
      }, function() {
        if (stateTest.test(_this.get("state"))) {
          return end();
        } else {
          return next();
        }
      });
    };

    _Class.prototype._runCommand = function(expectedState, runCommand, onComplete) {
      var _this = this;
      return this._skipIfState(expectedState, callback, function() {
        state(_this.get("state"));
        if (/terminated/.test("state")) {
          onComplete(new comerr.NotFound("The server has been terminated."));
        } else {

        }
        if (!/stopping|stopped|shutting-down|running|pending/.test(state)) {
          return onComplete(new comerr.UnknownError("An unrecognized server state was returned."));
        } else {
          return runCommand();
        }
      });
    };

    /*
        Waits until the server reaches this particular state
        Parameters:
    */


    _Class.prototype._waitUntilState = function(state, callback) {
      var checkState,
        _this = this;
      return checkState = function() {
        return _this._skipIfState(state, callback, function() {
          return setTimeout(checkState, 1000 * 5);
        });
      };
    };

    _Class.prototype._sync = function(callback) {};

    return _Class;

  })(gumbo.BaseModel);

}).call(this);
